1) Explain the components of the JDK.
JDK is Java Development kit which is used for the development of java applications. JDK consits of java compiler(javac), java runtime environment(jre), java API libraries, java virtual machine, java development tools and javafx. Each component have its different use like javac used for compilation, jvm used for execution of code and javafx used for gui applications.

2) Differentiate between JDK, JVM, and JRE.
JDK - jdk is java development kit used for development of applications. It consists of JRE, javac, jvm and other supportive tools and libraries. 
JRE - JRE is java runtime environment provides JVM for the execution of java program. It used for execution of java program, memory management and bytecode interpretation.
JVM - JVM is java virtual machine. JVM takes the bytecode from java compiler(javac) and executes the program of user. JVM has garbage collection and memory management.


3) What is the role of the JVM in Java? & How does the JVM execute Java code?
JVM is used for the execution of code, memory management and garbage collection. It takes the bytecode generated by java compiler and the main function is the entry point of java code, the jvm uses main thread to run the program. The java stacks in jvm are used for methods. The class loader is used for the loading of important classes at the time of program execution.

4) Explain the memory management system of the JVM.
In JVM, whenever we create a new object it is created in heap area. It gets its of address. There is String constant pool at method area to store similar strings. The method area is used for the .class files which are loaded by the class loader subsystem. the instance variables are also stored on heap. The static variables in java are stored in static block in method area. The garbage collection is used for the object with no references and it is called when any object is dereferenced with System.gc() call internally. The garbage collector is located at heap area after 1.8 version of java. also scp is shifted in heap area.


5) What are the JIT compiler and its role in the JVM? What is the bytecode and why is it important for Java?
The JIT compiler is a runtime compiler that dynamically translates Java bytecode into native machine code, which is executed directly by the CPU. Unlike traditional ahead-of-time compilers, which translate source code into machine code before execution, the JIT compiler performs compilation at runtime. JIT compiler is to improve the performance of Java applications by converting frequently executed bytecode sequences into optimized native machine code. It analyzes the behavior of the program during execution, identifying patterns, and optimizing code accordingly. Bytecode is generated by the javac compiler and the bytecode is secure, it can't be changed. The bytecode of java is platform independent that bytecode can be taken to any operating system, it works properly with jvm and gives the outputs. The bytecode written in assembly language. We can't read but javap tool used to deassemble the bytecode. While bytecode execution may initially incur some overhead compared to native code execution, the JIT compiler mitigates this performance gap by dynamically translating bytecode into optimized native machine code.

6) Describe the architecture of the JVM.
JVM is java virtual machine. It consists of class loader subsystem, java stacks, method area, heap area, pc registers, native method stack, JIT compiler, native method interface and garbage collector. Each component of jvm comes at different step of program execution. java stacks used for the methods of java to keep track each method gets one pc register. The native method stack used for the processing of the native methods. JIT compiler used for the dynamic translation of bytecode into optimized machine code. Garbage collection used for destroying dereferced objects from heap area. Newly created objects are stored in Heap area. The method area is used for storage of .class and static block. Also, the class loader subsystem loads all required .class files to method area. 


7) How does Java achieve platform independence through the JVM?
When you compile a Java source code file (.java file) using the Java compiler (javac), it translates the source code into bytecode instructions. Bytecode is a platform-independent intermediate representation of the Java program.Instead of directly executing the machine-specific instructions of the compiled code, Java bytecode is executed by the JVM. The JVM interprets or compiles bytecode into native machine code suitable for the underlying hardware and operating system. This interpretation or compilation process occurs at runtime, allowing Java programs to run on any platform with a compatible JVM implementation.While the JVM abstracts away the platform-specific details, it is implemented differently for each platform.Java's platform independence is often summarized by the principle of "write once, run anywhere" (WORA). This means that you can write Java code once and run it on any platform with a compatible JVM, without needing to make changes to the code for different operating systems or hardware architectures.


8) What is the significance of the class loader in Java? What is the process of garbage collection in Java.
j1ava applications can dynamically load classes at runtime using Class Loaders. This enables features such as plugin systems, where new functionality can be added to an application without requiring a restart. In Java, classes can be unloaded from memory when they are no longer needed, typically when their associated Class Loader is garbage collected. This allows the JVM to reclaim memory occupied by unused classes, reducing memory footprint and preventing memory leaks. The garbage collector starts by identifying reachable objects, which are objects that are still referenced by active threads or by other reachable objects. The root set, which includes global references such as static variables and local variables in active thread stacks, serves as the starting point for this process. Objects with finalizers may undergo a finalization process before being reclaimed by the garbage collector. Finalization allows objects to perform cleanup actions or release external resources before they are destroyed. However, finalization can impact garbage collection performance and is often considered a less efficient mechanism for resource management. 